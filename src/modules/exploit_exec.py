"""
Exploit Execution module for the APT toolkit.

This module provides functionality for executing exploits against vulnerable
targets, managing exploit sessions, and integrating with the payload generation
module for payload delivery.
"""

import os
import re
import time
import json
import socket
import random
import string
import hashlib
import threading
import subprocess
from typing import Dict, List, Set, Tuple, Optional, Union, Any, Callable
from dataclasses import dataclass, field, asdict
from enum import Enum, auto
from pathlib import Path
from urllib.parse import urlparse

from src.utils.logger import get_module_logger
from src.utils.config import ConfigManager
from src.utils.network import NetworkUtils, network_utils
from src.modules.payload_gen import Payload, PayloadType, PayloadFormat, PayloadPlatform

logger = get_module_logger("exploit_exec")

class ExploitType(Enum):
    """Enumeration of exploit types"""
    WEB = auto()
    NETWORK = auto()
    LOCAL = auto()
    REMOTE_CODE_EXECUTION = auto()
    COMMAND_INJECTION = auto()
    SQL_INJECTION = auto()
    XSS = auto()
    FILE_INCLUSION = auto()
    FILE_UPLOAD = auto()
    BUFFER_OVERFLOW = auto()
    FORMAT_STRING = auto()
    RACE_CONDITION = auto()
    PRIVILEGE_ESCALATION = auto()
    AUTHENTICATION_BYPASS = auto()
    CUSTOM = auto()

class ExploitStatus(Enum):
    """Enumeration of exploit status"""
    READY = auto()
    RUNNING = auto()
    COMPLETED = auto()
    FAILED = auto()
    CANCELLED = auto()

class ExploitSessionStatus(Enum):
    """Enumeration of exploit session status"""
    ACTIVE = auto()
    DORMANT = auto()
    CLOSED = auto()
    DETECTED = auto()
    UNSTABLE = auto()

@dataclass
class ExploitTarget:
    """Data class for exploit target information"""
    host: str  # IP or hostname
    port: int = 0
    protocol: str = "tcp"
    url: str = ""
    username: str = ""
    password: str = ""
    os_type: str = ""  # windows, linux, macos, etc.
    os_version: str = ""
    service: str = ""
    service_version: str = ""
    vulnerability: str = ""  # CVE, etc.
    notes: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate and normalize target information"""
        # If URL is provided, extract host and port
        if self.url and not self.host:
            parsed_url = urlparse(self.url)
            self.host = parsed_url.hostname or ""
            if parsed_url.port:
                self.port = parsed_url.port
            elif parsed_url.scheme == "https":
                self.port = 443
            elif parsed_url.scheme == "http":
                self.port = 80

@dataclass
class Exploit:
    """Data class for exploit information"""
    name: str
    type: ExploitType
    description: str = ""
    target_service: str = ""
    target_version: str = ""
    cve: str = ""
    author: str = ""
    date: str = ""
    references: List[str] = field(default_factory=list)
    payload: Optional[Payload] = None
    payload_type: Optional[PayloadType] = None
    requirements: List[str] = field(default_factory=list)
    options: Dict[str, Any] = field(default_factory=dict)
    code: str = ""
    custom_function: Optional[Callable] = None
    status: ExploitStatus = ExploitStatus.READY
    notes: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization"""
        result = asdict(self)
        # Remove non-serializable fields
        result.pop("custom_function", None)
        if self.payload:
            result["payload"] = self.payload.to_dict()
        return result
    
    def to_json(self, pretty: bool = True) -> str:
        """Convert to JSON string"""
        if pretty:
            return json.dumps(self.to_dict(), indent=4)
        return json.dumps(self.to_dict())
    
    def save_to_file(self, filename: str) -> bool:
        """Save exploit to a file"""
        try:
            with open(filename, 'w') as f:
                f.write(self.to_json())
            logger.info(f"Saved exploit to {filename}")
            return True
        except Exception as e:
            logger.error(f"Failed to save exploit to {filename}: {e}")
            return False
    
    @classmethod
    def load_from_file(cls, filename: str) -> Optional['Exploit']:
        """
        Load exploit from a file.
        
        Args:
            filename: Path to exploit file
            
        Returns:
            Exploit: Loaded exploit or None if loading failed
        """
        try:
            with open(filename, 'r') as f:
                data = json.load(f)
            
            # Create exploit
            exploit = cls(
                name=data.get("name", ""),
                type=ExploitType[data.get("type", "CUSTOM")],
                description=data.get("description", ""),
                target_service=data.get("target_service", ""),
                target_version=data.get("target_version", ""),
                cve=data.get("cve", ""),
                author=data.get("author", ""),
                date=data.get("date", ""),
                references=data.get("references", []),
                payload_type=PayloadType[data.get("payload_type", "CUSTOM")] if data.get("payload_type") else None,
                requirements=data.get("requirements", []),
                options=data.get("options", {}),
                code=data.get("code", ""),
                status=ExploitStatus[data.get("status", "READY")],
                notes=data.get("notes", [])
            )
            
            logger.info(f"Loaded exploit from {filename}")
            return exploit
            
        except Exception as e:
            logger.error(f"Failed to load exploit from {filename}: {e}")
            return None

@dataclass
class ExploitResult:
    """Data class for exploit execution results"""
    exploit: Exploit
    target: ExploitTarget
    start_time: float = field(default_factory=time.time)
    end_time: float = 0.0
    status: ExploitStatus = ExploitStatus.RUNNING
    success: bool = False
    session_established: bool = False
    session_id: str = ""
    output: str = ""
    error: str = ""
    notes: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization"""
        result = {
            "exploit": self.exploit.to_dict(),
            "target": asdict(self.target),
            "start_time": self.start_time,
            "end_time": self.end_time,
            "status": self.status.name,
            "success": self.success,
            "session_established": self.session_established,
            "session_id": self.session_id,
            "output": self.output,
            "error": self.error,
            "notes": self.notes
        }
        return result
    
    def to_json(self, pretty: bool = True) -> str:
        """Convert to JSON string"""
        if pretty:
            return json.dumps(self.to_dict(), indent=4)
        return json.dumps(self.to_dict())
    
    def save_to_file(self, filename: str) -> bool:
        """Save result to a file"""
        try:
            with open(filename, 'w') as f:
                f.write(self.to_json())
            logger.info(f"Saved exploit result to {filename}")
            return True
        except Exception as e:
            logger.error(f"Failed to save exploit result to {filename}: {e}")
            return False
    
    def get_duration(self) -> float:
        """Get execution duration in seconds"""
        if self.end_time > 0:
            return self.end_time - self.start_time
        return time.time() - self.start_time

@dataclass
class ExploitSession:
    """Data class for exploit session information"""
    session_id: str
    exploit_result: ExploitResult
    start_time: float = field(default_factory=time.time)
    last_active: float = field(default_factory=time.time)
    status: ExploitSessionStatus = ExploitSessionStatus.ACTIVE
    connection: Any = None  # Socket, HTTP connection, etc.
    commands_history: List[str] = field(default_factory=list)
    output_history: List[str] = field(default_factory=list)
    notes: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization"""
        result = {
            "session_id": self.session_id,
            "exploit_result": self.exploit_result.to_dict(),
            "start_time": self.start_time,
            "last_active": self.last_active,
            "status": self.status.name,
            "commands_history": self.commands_history,
            "output_history": self.output_history,
            "notes": self.notes
        }
        return result
    
    def to_json(self, pretty: bool = True) -> str:
        """Convert to JSON string"""
        if pretty:
            return json.dumps(self.to_dict(), indent=4)
        return json.dumps(self.to_dict())
    
    def get_duration(self) -> float:
        """Get session duration in seconds"""
        return time.time() - self.start_time
    
    def get_idle_time(self) -> float:
        """Get idle time in seconds"""
        return time.time() - self.last_active


class ExploitExecModule:
    """
    Exploit execution module for executing exploits against vulnerable targets,
    managing exploit sessions, and integrating with the payload generation module.
    """
    
    def __init__(self, config: Optional[ConfigManager] = None):
        """
        Initialize the exploit execution module.
        
        Args:
            config: Optional configuration manager instance.
        """
        self.config = config
        
        # Initialize network utilities
        if config:
            self.network = NetworkUtils(config)
        else:
            self.network = network_utils
            
        # Load configuration settings
        self.output_dir = "results/exploits"
        self.exploits_dir = "exploits"
        self.timeout = 30
        self.max_retries = 3
        self.safe_mode = True  # Limits potentially harmful exploits
        
        if config:
            self.output_dir = config.get("modules.exploit_exec.output_dir", "results/exploits")
            self.exploits_dir = config.get("modules.exploit_exec.exploits_dir", "exploits")
            self.timeout = config.get("modules.exploit_exec.timeout", 30)
            self.max_retries = config.get("modules.exploit_exec.max_retries", 3)
            self.safe_mode = config.get("modules.exploit_exec.safe_mode", True)
            
            # Create output directories if they don't exist
            for directory in [self.output_dir, self.exploits_dir]:
                if directory and not os.path.exists(directory):
                    try:
                        os.makedirs(directory)
                        logger.info(f"Created directory: {directory}")
                    except Exception as e:
                        logger.error(f"Failed to create directory {directory}: {e}")
        
        # Initialize exploits and sessions
        self.exploits = {}
        self.sessions = {}
        
        # Load exploits from directory
        self._load_exploits()
    
    def _load_exploits(self) -> None:
        """Load exploits from exploits directory"""
        if not os.path.exists(self.exploits_dir):
            return
        
        for filename in os.listdir(self.exploits_dir):
            if filename.endswith(".json"):
                try:
                    exploit = Exploit.load_from_file(os.path.join(self.exploits_dir, filename))
                    if exploit:
                        self.exploits[exploit.name] = exploit
                except Exception as e:
                    logger.error(f"Failed to load exploit from {filename}: {e}")
    
    def create_exploit(self, name: str, type: ExploitType, code: str,
                      description: Optional[str] = None,
                      target_service: Optional[str] = None,
                      target_version: Optional[str] = None,
                      cve: Optional[str] = None,
                      author: Optional[str] = None,
                      payload: Optional[Payload] = None,
                      options: Optional[Dict[str, Any]] = None) -> Exploit:
        """
        Create a new exploit.
        
        Args:
            name: Exploit name
            type: Exploit type
            code: Exploit code
            description: Optional description
            target_service: Optional target service
            target_version: Optional target version
            cve: Optional CVE identifier
            author: Optional author
            payload: Optional payload
            options: Optional options
            
        Returns:
            Exploit: Created exploit
        """
        exploit = Exploit(
            name=name,
            type=type,
            description=description or f"{name} exploit",
            target_service=target_service or "",
            target_version=target_version or "",
            cve=cve or "",
            author=author or "",
            date=time.strftime("%Y-%m-%d"),
            code=code,
            options=options or {},
            payload=payload,
            payload_type=payload.type if payload else None
        )
        
        # Add to exploits
        self.exploits[name] = exploit
        
        logger.info(f"Created exploit '{name}'")
        return exploit
    
    def save_exploit(self, exploit: Exploit) -> bool:
        """
        Save an exploit to the exploits directory.
        
        Args:
            exploit: Exploit to save
            
        Returns:
            bool: True if successful, False otherwise
        """
        if not os.path.exists(self.exploits_dir):
            try:
                os.makedirs(self.exploits_dir)
            except Exception as e:
                logger.error(f"Failed to create exploits directory: {e}")
                return False
        
        try:
            # Save exploit
            filename = os.path.join(self.exploits_dir, f"{exploit.name.lower().replace(' ', '_')}.json")
            exploit.save_to_file(filename)
            
            logger.info(f"Saved exploit '{exploit.name}' to {filename}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save exploit '{exploit.name}': {e}")
            return False
    
    def execute_exploit(self, exploit_name: str, target: ExploitTarget, 
                       payload: Optional[Payload] = None,
                       options: Optional[Dict[str, Any]] = None) -> ExploitResult:
        """
        Execute an exploit against a target.
        
        Args:
            exploit_name: Name of the exploit to execute
            target: Target to exploit
            payload: Optional payload to use
            options: Optional options to override exploit options
            
        Returns:
            ExploitResult: Exploit execution result
        """
        # Check if exploit exists
        if exploit_name not in self.exploits:
            logger.error(f"Exploit '{exploit_name}' not found")
            return ExploitResult(
                exploit=Exploit(name=exploit_name, type=ExploitType.CUSTOM),
                target=target,
                status=ExploitStatus.FAILED,
                error=f"Exploit '{exploit_name}' not found"
            )
        
        exploit = self.exploits[exploit_name]
        
        # Update exploit with payload if provided
        if payload:
            exploit.payload = payload
            exploit.payload_type = payload.type
        
        # Update exploit options if provided
        if options:
            exploit.options.update(options)
        
        # Check if exploit is ready
        if exploit.status != ExploitStatus.READY:
            logger.error(f"Exploit '{exploit_name}' is not ready (status: {exploit.status.name})")
            return ExploitResult(
                exploit=exploit,
                target=target,
                status=ExploitStatus.FAILED,
                error=f"Exploit is not ready (status: {exploit.status.name})"
            )
        
        # Check if payload is required but not provided
        if exploit.payload_type and not exploit.payload:
            logger.error(f"Exploit '{exploit_name}' requires a payload of type {exploit.payload_type.name}")
            return ExploitResult(
                exploit=exploit,
                target=target,
                status=ExploitStatus.FAILED,
                error=f"Exploit requires a payload of type {exploit.payload_type.name}"
            )
        
        # Initialize result
        result = ExploitResult(
            exploit=exploit,
            target=target,
            status=ExploitStatus.RUNNING
        )
        
        logger.info(f"Executing exploit '{exploit_name}' against {target.host}:{target.port}")
        
        try:
            # Execute exploit based on type
            if exploit.type == ExploitType.WEB:
                self._execute_web_exploit(exploit, target, result)
            elif exploit.type == ExploitType.NETWORK:
                self._execute_network_exploit(exploit, target, result)
            elif exploit.type == ExploitType.REMOTE_CODE_EXECUTION:
                self._execute_rce_exploit(exploit, target, result)
            elif exploit.type == ExploitType.COMMAND_INJECTION:
                self._execute_command_injection_exploit(exploit, target, result)
            elif exploit.type == ExploitType.SQL_INJECTION:
                self._execute_sql_injection_exploit(exploit, target, result)
            elif exploit.custom_function:
                # Use custom execution function
                exploit.custom_function(exploit, target, result)
            else:
                # Generic execution
                self._execute_generic_exploit(exploit, target, result)
            
            # Update result status
            if result.status == ExploitStatus.RUNNING:
                if result.success:
                    result.status = ExploitStatus.COMPLETED
                else:
                    result.status = ExploitStatus.FAILED
            
            # Set end time
            result.end_time = time.time()
            
            # Create session if successful and session was established
            if result.success and result.session_established:
                session_id = self._create_session(result)
                result.session_id = session_id
                result.notes.append(f"Session established: {session_id}")
            
            # Save result
            self._save_result(result)
            
            logger.info(f"Exploit execution completed: success={result.success}")
            
        except Exception as e:
            error_msg = f"Error executing exploit: {str(e)}"
            logger.error(error_msg)
            result.error = error_msg
            result.status = ExploitStatus.FAILED
            result.end_time = time.time()
        
        return result
    
    def _execute_web_exploit(self, exploit: Exploit, target: ExploitTarget, result: ExploitResult) -> None:
        """
        Execute a web exploit.
        
        Args:
            exploit: Exploit to execute
            target: Target to exploit
            result: Result to update
        """
        # Ensure target has a URL
        if not target.url:
            if target.host:
                protocol = "https" if target.port == 443 else "http"
                target.url = f"{protocol}://{target.host}:{target.port}"
            else:
                result.error = "Target URL not specified"
                result.status = ExploitStatus.FAILED
                return
        
        try:
            # Get exploit options
            method = exploit.options.get("method", "GET")
            path = exploit.options.get("path", "/")
            headers = exploit.options.get("headers", {})
            cookies = exploit.options.get("cookies", {})
            data = exploit.options.get("data", {})
            
            # Add payload to appropriate location if available
            if exploit.payload:
                payload_location = exploit.options.get("payload_location", "body")
                payload_param = exploit.options.get("payload_param", "")
                
                if payload_location == "url" and payload_param:
                    path = path.replace(f"{{{payload_param}}}", exploit.payload.content)
                elif payload_location == "header" and payload_param:
                    headers[payload_param] = exploit.payload.content
                elif payload_location == "cookie" and payload_param:
                    cookies[payload_param] = exploit.payload.content
                elif payload_location == "body" and payload_param:
                    data[payload_param] = exploit.payload.content
                elif payload_location == "body_raw":
                    data = exploit.payload.content
            
            # Construct full URL
            url = target.url
            if not url.endswith("/") and not path.startswith("/"):
                url += "/"
            url += path.lstrip("/")
            
            # Send request
            if method.upper() == "GET":
                status, response_headers, body = self.network.get_http_request(
                    url,
                    headers=headers,
                    cookies=cookies,
                    timeout=self.timeout,
                    verify_ssl=False
                )
            else:  # POST, PUT, etc.
                status, response_headers, body = self.network.post_http_request(
                    url,
                    data=data,
                    headers=headers,
                    cookies=cookies,
                    method=method.upper(),
                    timeout=self.timeout,
                    verify_ssl=False
                )
            
            # Check for success indicators
            success_indicators = exploit.options.get("success_indicators", [])
            failure_indicators = exploit.options.get("failure_indicators", [])
            
            if self._check_indicators(body, success_indicators, failure_indicators):
                result.success = True
                result.output = body
                
                # Check for session indicators
                session_indicators = exploit.options.get("session_indicators", [])
                if session_indicators and any(indicator in body for indicator in session_indicators):
                    result.session_established = True
                    
                    # Extract session cookies if available
                    if "Set-Cookie" in response_headers:
                        result.notes.append(f"Session cookies: {response_headers['Set-Cookie']}")
            else:
                result.success = False
                result.output = body
                result.error = "Success indicators not found in response"
            
        except Exception as e:
            result.success = False
            result.error = f"Web exploit execution failed: {str(e)}"
    
    def _execute_network_exploit(self, exploit: Exploit, target: ExploitTarget, result: ExploitResult) -> None:
        """
        Execute a network exploit.
        
        Args:
            exploit: Exploit to execute
            target: Target to exploit
            result: Result to update
        """
        # Ensure target has host and port
        if not target.host:
            result.error = "Target host not specified"
            result.status = ExploitStatus.FAILED
            return
        
        if not target.port:
            result.error = "Target port not specified"
            result.status = ExploitStatus.FAILED
            return
        
        try:
            # Get exploit options
            protocol = target.protocol.lower()
            timeout = exploit.options.get("timeout", self.timeout)
            retries = exploit.options.get("retries", self.max_retries)
            delay = exploit.options.get("delay", 1.0)
            
            # Prepare payload
            payload_data = b""
            if exploit.payload:
                payload_data = exploit.payload.content.encode()
            elif "payload_data" in exploit.options:
                payload_data = exploit.options["payload_data"].encode()
            
            # Execute exploit based on protocol
            if protocol == "tcp":
                self._execute_tcp_exploit(target.host, target.port, payload_data, timeout, retries, delay, result)
            elif protocol == "udp":
                self._execute_udp_exploit(target.host, target.port, payload_data, timeout, retries, delay, result)
            else:
                result.error = f"Unsupported protocol: {protocol}"
                result.status = ExploitStatus.FAILED
            
        except Exception as e:
            result.success = False
            result.error = f"Network exploit execution failed: {str(e)}"
    
    def _execute_tcp_exploit(self, host: str, port: int, payload: bytes, 
                            timeout: float, retries: int, delay: float, 
                            result: ExploitResult) -> None:
        """
        Execute a TCP exploit.
        
        Args:
            host: Target host
            port: Target port
            payload: Payload data
            timeout: Connection timeout
            retries: Number of retries
            delay: Delay between retries
            result: Result to update
        """
        for attempt in range(retries + 1):
            try:
                # Create socket
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                
                # Connect to target
                sock.connect((host, port))
                
                # Send payload
                if payload:
                    sock.send(payload)
                
                # Receive response
                response = b""
                try:
                    while True:
                        data = sock.recv(4096)
                        if not data:
                            break
                        response += data
                except socket.timeout:
                    pass
                
                # Close socket
                sock.close()
                
                # Check for success
                if response:
                    result.success = True
                    result.output = response.decode('utf-8', errors='ignore')
                    
                    # Check for session indicators
                    session_indicators = result.exploit.options.get("session_indicators", [])
                    if session_indicators and any(indicator.encode() in response for indicator in session_indicators):
                        result.session_established = True
                    
                    return
                
                # If we get here, no response was received
                if attempt < retries:
                    time.sleep(delay)
                    continue
                
                result.success = False
                result.error = "No response received"
                
            except Exception as e:
                if attempt < retries:
                    time.sleep(delay)
                    continue
                
                result.success = False
                result.error = f"TCP exploit failed: {str(e)}"
    
    def _execute_udp_exploit(self, host: str, port: int, payload: bytes, 
                            timeout: float, retries: int, delay: float, 
                            result: ExploitResult) -> None:
        """
        Execute a UDP exploit.
        
        Args:
            host: Target host
            port: Target port
            payload: Payload data
            timeout: Connection timeout
            retries: Number of retries
            delay: Delay between retries
            result: Result to update
        """
        for attempt in range(retries + 1):
            try:
                # Create socket
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(timeout)
                
                # Send payload
                if payload:
                    sock.sendto(payload, (host, port))
                
                # Receive response
                response = b""
                try:
                    data, addr = sock.recvfrom(4096)
                    response = data
                except socket.timeout:
                    pass
                
                # Close socket
                sock.close()
                
                # Check for success
                if response:
                    result.success = True
                    result.output = response.decode('utf-8', errors='ignore')
                    return
                
                # If we get here, no response was received
                if attempt < retries:
                    time.sleep(delay)
                    continue
                
                result.success = False
                result.error = "No response received"
                
            except Exception as e:
                if attempt < retries:
                    time.sleep(delay)
                    continue
                
                result.success = False
                result.error = f"UDP exploit failed: {str(e)}"
    
    def _execute_rce_exploit(self, exploit: Exploit, target: ExploitTarget, result: ExploitResult) -> None:
        """
        Execute a remote code execution exploit.
        
        Args:
            exploit: Exploit to execute
            target: Target to exploit
            result: Result to update
        """
        # RCE exploits can use different protocols
        if "protocol" in exploit.options:
            protocol = exploit.options["protocol"].lower()
            
            if protocol == "http":
                self._execute_web_exploit(exploit, target, result)
            elif protocol in ["tcp", "udp"]:
                self._execute_network_exploit(exploit, target, result)
            else:
                result.error = f"Unsupported protocol for RCE exploit: {protocol}"
                result.status = ExploitStatus.FAILED
        else:
            # Default to web exploit
            self._execute_web_exploit(exploit, target, result)
    
    def _execute_command_injection_exploit(self, exploit: Exploit, target: ExploitTarget, result: ExploitResult) -> None:
        """
        Execute a command injection exploit.
        
        Args:
            exploit: Exploit to execute
            target: Target to exploit
            result: Result to update
        """
        # Command injection is typically done via web
        self._execute_web_exploit(exploit, target, result)
    
    def _execute_sql_injection_exploit(self, exploit: Exploit, target: ExploitTarget, result: ExploitResult) -> None:
        """
        Execute a SQL injection exploit.
        
        Args:
            exploit: Exploit to execute
            target: Target to exploit
            result: Result to update
        """
        # SQL injection is typically done via web
        self._execute_web_exploit(exploit, target, result)
    
    def _execute_generic_exploit(self, exploit: Exploit, target: ExploitTarget, result: ExploitResult) -> None:
        """
        Execute a generic exploit.
        
        Args:
            exploit: Exploit to execute
            target: Target to exploit
            result: Result to update
        """
        # Check if exploit has code
        if not exploit.code:
            result.error = "Exploit has no code"
            result.status = ExploitStatus.FAILED
            return
        
        try:
            # Create a temporary file with the exploit code
            temp_dir = os.path.join(self.output_dir, "temp")
            if not os.path.exists(temp_dir):
                os.makedirs(temp_dir)
            
            temp_file = os.path.join(temp_dir, f"{exploit.name.lower().replace(' ', '_')}.py")
            with open(temp_file, 'w') as f:
                f.write(exploit.code)
            
            # Prepare command arguments
            args = [
                "python", temp_file,
                "--host", target.host
            ]
            
            if target.port:
                args.extend(["--port", str(target.port)])
            
            if target.username:
                args.extend(["--username", target.username])
            
            if target.password:
                args.extend(["--password", target.password])
            
            if exploit.payload:
                args.extend(["--payload", exploit.payload.content])
            
            # Add additional options
            for key, value in exploit.options.items():
                if isinstance(value, bool):
                    if value:
                        args.append(f"--{key}")
                else:
                    args.extend([f"--{key}", str(value)])
            
            # Execute the exploit
            process = subprocess.Popen(
                args,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            # Wait for completion with timeout
            try:
                stdout, stderr = process.communicate(timeout=self.timeout)
                
                # Check result
                if process.returncode == 0:
                    result.success = True
                    result.output = stdout
                    
                    # Check for session establishment
                    if "SESSION ESTABLISHED" in stdout:
                        result.session_established = True
                else:
                    result.success = False
                    result.error = stderr
                    result.output = stdout
                
            except subprocess.TimeoutExpired:
                process.kill()
                result.success = False
                result.error = "Exploit execution timed out"
            
            # Clean up
            try:
                os.remove(temp_file)
            except:
                pass
            
        except Exception as e:
            result.success = False
            result.error = f"Generic exploit execution failed: {str(e)}"
    
    def _check_indicators(self, content: str, success_indicators: List[str], failure_indicators: List[str]) -> bool:
        """
        Check for success and failure indicators in content.
        
        Args:
            content: Content to check
            success_indicators: List of success indicators
            failure_indicators: List of failure indicators
            
        Returns:
            bool: True if success indicators found and no failure indicators found
        """
        # Check for failure indicators first
        for indicator in failure_indicators:
            if indicator in content:
                return False
        
        # If no success indicators specified, assume success
        if not success_indicators:
            return True
        
        # Check for success indicators
        for indicator in success_indicators:
            if indicator in content:
                return True
        
        return False
    
    def _create_session(self, result: ExploitResult) -> str:
        """
        Create a session from an exploit result.
        
        Args:
            result: Exploit result
            
        Returns:
            str: Session ID
        """
        # Generate session ID
        session_id = hashlib.md5(f"{result.target.host}:{result.target.port}:{time.time()}".encode()).hexdigest()
        
        # Create session
        session = ExploitSession(
            session_id=session_id,
            exploit_result=result,
            status=ExploitSessionStatus.ACTIVE
        )
        
        # Add to sessions
        self.sessions[session_id] = session
        
        logger.info(f"Created session {session_id}")
        return session_id
    
    def _save_result(self, result: ExploitResult) -> None:
        """
        Save an exploit result to the output directory.
        
        Args:
            result: Exploit result to save
        """
        if not os.path.exists(self.output_dir):
            try:
                os.makedirs(self.output_dir)
            except Exception as e:
                logger.error(f"Failed to create output directory: {e}")
                return
        
        try:
            # Save result
            timestamp = int(time.time())
            filename = os.path.join(
                self.output_dir, 
                f"{result.exploit.name.lower().replace(' ', '_')}_{result.target.host}_{timestamp}.json"
            )
            result.save_to_file(filename)
            
            logger.info(f"Saved exploit result to {filename}")
            
        except Exception as e:
            logger.error(f"Failed to save exploit result: {e}")
    
    def get_session(self, session_id: str) -> Optional[ExploitSession]:
        """
        Get a session by ID.
        
        Args:
            session_id: Session ID
            
        Returns:
            ExploitSession: Session or None if not found
        """
        return self.sessions.get(session_id)
    
    def get_active_sessions(self) -> Dict[str, ExploitSession]:
        """
        Get all active sessions.
        
        Returns:
            Dict[str, ExploitSession]: Dictionary of active sessions
        """
        return {sid: session for sid, session in self.sessions.items() 
                if session.status == ExploitSessionStatus.ACTIVE}
    
    def interact_with_session(self, session_id: str, command: str) -> Optional[str]:
        """
        Interact with a session.
        
        Args:
            session_id: Session ID
            command: Command to execute
            
        Returns:
            str: Command output or None if session not found or inactive
        """
        # Check if session exists
        if session_id not in self.sessions:
            logger.error(f"Session {session_id} not found")
            return None
        
        session = self.sessions[session_id]
        
        # Check if session is active
        if session.status != ExploitSessionStatus.ACTIVE:
            logger.error(f"Session {session_id} is not active (status: {session.status.name})")
            return None
        
        try:
            # Update last active time
            session.last_active = time.time()
            
            # Add command to history
            session.commands_history.append(command)
            
            # Execute command based on session type
            output = self._execute_session_command(session, command)
            
            # Add output to history
            session.output_history.append(output)
            
            return output
            
        except Exception as e:
            error_msg = f"Error executing command in session {session_id}: {str(e)}"
            logger.error(error_msg)
            return error_msg
    
    def _execute_session_command(self, session: ExploitSession, command: str) -> str:
        """
        Execute a command in a session.
        
        Args:
            session: Session to execute command in
            command: Command to execute
            
        Returns:
            str: Command output
        """
        # This is a placeholder implementation
        # In a real implementation, this would depend on the type of session
        
        # For demonstration, we'll just return a dummy response
        return f"Executed command: {command}\nOutput: [Simulated output]"
    
    def close_session(self, session_id: str) -> bool:
        """
        Close a session.
        
        Args:
            session_id: Session ID
            
        Returns:
            bool: True if successful, False otherwise
        """
        # Check if session exists
        if session_id not in self.sessions:
            logger.error(f"Session {session_id} not found")
            return False
        
        session = self.sessions[session_id]
        
        try:
            # Close session based on type
            # This is a placeholder implementation
            
            # Update session status
            session.status = ExploitSessionStatus.CLOSED
            
            logger.info(f"Closed session {session_id}")
            return True
            
        except Exception as e:
            logger.error(f"Error closing session {session_id}: {str(e)}")
            return False
    
    def get_available_exploits(self, type: Optional[ExploitType] = None, 
                              target_service: Optional[str] = None,
                              cve: Optional[str] = None) -> Dict[str, Exploit]:
        """
        Get available exploits, optionally filtered by type, target service, or CVE.
        
        Args:
            type: Optional exploit type filter
            target_service: Optional target service filter
            cve: Optional CVE filter
            
        Returns:
            Dict[str, Exploit]: Dictionary of matching exploits
        """
        exploits = {}
        
        for name, exploit in self.exploits.items():
            if type and exploit.type != type:
                continue
            if target_service and exploit.target_service != target_service:
                continue
            if cve and exploit.cve != cve:
                continue
            
            exploits[name] = exploit
        
        return exploits